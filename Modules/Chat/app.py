# agentzero/Modules/Chat/app.py
from fastapi import FastAPI, Request, WebSocket, APIRouter, Cookie
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, HTMLResponse
from typing import Optional
import json
import logging
import uuid
import os
from agentzero.LLM import ChatProcessor
from pydantic import BaseModel
from starlette.websockets import WebSocketDisconnect

chat_router = APIRouter()

logging.basicConfig(level=logging.DEBUG)

CHAT_DIR = os.path.dirname(__file__)

class ChatSession(BaseModel):
    chat_id: Optional[str]
    user_id: Optional[str]


@chat_router.post('/init_chat', response_class=JSONResponse)
async def init_chat(request: Request, user_id: Optional[str] = Cookie(None)):
    if not user_id:
        user_id = str(uuid.uuid4())
    chat_id = str(uuid.uuid4())
    return JSONResponse(content={"user_id": user_id, "chat_id": chat_id})


@chat_router.get('/models', response_class=dict)
async def list_models():
    """
    Lists all available models by querying the model deployment service.
    Returns a list of models with their details including the listen port for ChatProcessor calls.

    Args:
        None

    Returns:
        dict: A dictionary containing a list of available models and their details.
    """
    from fastapi.responses import JSONResponse
    import httpx

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                'http://localhost:7777/serving/deployments',
            )
            response.raise_for_status()
            model_deployments = response.json()
            model_details = [
                {
                    "m_id": md.get("m_id", "default"),
                    "host_name": md.get("host_name", "localhost"),
                    "m_name": md.get("m_name", "default"),
                    "listen_port": md.get("listen_port", "8000"),
                    "status": md.get("status", "DEPLOYED"),
                    "deployed_at": md.get("deployed_at", "untracked")
                } for md in model_deployments
            ]

            return JSONResponse(content={"models": model_details})
    except httpx.HTTPError as e:
        logging.error(f"Failed to fetch models: {e}")
        return JSONResponse(content={"error": "Failed to fetch models"}, status_code=500)
    except Exception as e:
        logging.error(f"An unexpected error occurred: {e}")
        return JSONResponse(content={"error": "An unexpected error occurred"}, status_code=500)
async def process_input(user_id: str, chat_id: str, user_input: str, host_name: str, listen_port: str, model_name: str, stream_callback=None, enable_retrieval: bool = True) -> dict:
    """
    Processes the user input by generating a response using the ChatProcessor with updated parameters including model details.
    Restores the chat state from a file if it exists, and saves the updated state after processing.
    Adds the chat_id to the response if it exists.

    Args:
        user_id (str): The user's unique identifier.
        chat_id (str): The chat session's unique identifier.
        user_input (str): The input text from the user.
        host_name (str): The host address of the model server.
        listen_port (str): The port number of the model server.
        model_name (str): The name of the model to use for generating responses.
        stream_callback (callable, optional): A callback function for streaming data. Defaults to None.
        enable_retrieval (bool, optional): Whether to enable retrieval for the chat session. Defaults to True.

    Returns:
        dict: The response generated by the ChatProcessor, with chat_id added if it exists.
    """
    user_data_dir = os.path.join(CHAT_DIR, f"userdata/{user_id}")
    chat_state_file = os.path.join(user_data_dir, f"{chat_id}.json")
    processor = ChatProcessor(model=model_name, host_name=host_name, listen_port=int(listen_port), retrieval=enable_retrieval)
    try:
        processor.restore_state(file_path=chat_state_file)
    except FileNotFoundError as e:
        logging.error(f"Exception occurred restoring state: {e}")
    logging.debug("### process_input: generate response")
    response = await processor.generate_response(user_input, stream_callback=stream_callback)
    processor.dump_state(file_path=chat_state_file)
    
    # Add chat_id to the response if it exists
    if chat_id:
        response['chat_id'] = chat_id
    return response

@chat_router.websocket('/ws/{user_id}/{chat_id}/')
async def websocket_endpoint(websocket: WebSocket, user_id: str, chat_id: str):
    await websocket.accept()
    chunk_index = 0  # Initialize chunk index

    parameters = {}  # Dictionary to store additional parameters

    async def stream_callback(response_chunk):
        nonlocal chunk_index
        # Prepare a response chunk to be sent back to the client with an index
        response_with_type = {
            "type": "response_chunk",
            "chat_id": chat_id,
            "chunk_index": chunk_index,  # Add chunk index
            "response_chunk": response_chunk
        }
        chunk_index += 1  # Increment chunk index
        await websocket.send_text(json.dumps(response_with_type))

    while True:
        try:
            data = await websocket.receive_text()
            data_json = json.loads(data)

            if not parameters:
                # Extract additional parameters from the first message
                parameters = {
                    "host_name": data_json.get('host_name'),
                    "listen_port": data_json.get('listen_port'),
                    "model_name": data_json.get('model_name'),
                    "enable_retrieval": data_json.get('enable_retrieval')
                }
                # Check if any required parameter is missing
                if not all(parameters.values()):
                    logging.error("Missing parameters in initial message")
                    await websocket.close(code=1003)  # Close with unsupported data code
                    return

            user_input = data_json.get('user_input')
        except json.JSONDecodeError as e:
            logging.error(f"Error decoding JSON from WebSocket: {e}")
            continue
        except WebSocketDisconnect as e:
            logging.info(f"WebSocket disconnected: {e}. Client likely closed the connection.")
            break
        except Exception as e:
            logging.error(f"Unmatched exception in websocket: {e}")
            raise e

        if 'chat_id' in data_json and chat_id and chat_id != data_json.get('chat_id'):
            logging.error(f"chat_id mismatch: {chat_id} != {data_json.get('chat_id')}")
            response_with_type = {"type": "error", "message": "There was a problem with your chat. Please start a new chat."}
            await websocket.send_text(json.dumps(response_with_type))
            continue

        if user_input:
            response = await process_input(
                user_id=user_id,
                chat_id=chat_id,
                user_input=user_input,
                stream_callback=stream_callback,
                host_name=parameters['host_name'],
                listen_port=parameters['listen_port'],
                model_name=parameters['model_name'],
                enable_retrieval=parameters['enable_retrieval']
            )
            response_with_type = {"type": "response", **response}
            await websocket.send_text(json.dumps(response_with_type))
        else:
            logging.error("Received data does not contain 'user_input'")

# Function to process user input
async def process_input(user_id, chat_id, user_input, stream_callback, host_name, listen_port, model_name, enable_retrieval):
    # Implement the actual processing logic here
    response = {
        "user_id": user_id,
        "chat_id": chat_id,
        "user_input": user_input,
        "response_message": "Processed input",
        "host_name": host_name,
        "listen_port": listen_port,
        "model_name": model_name,
        "enable_retrieval": enable_retrieval
    }
    await stream_callback("This is a streamed response chunk.")
    return response
            

@chat_router.get('/chats/{chat_id}', response_class=JSONResponse)
async def get_chat_history(chat_id: str, user_id: Optional[str] = Cookie(None)):
    user_data_path = os.path.join(CHAT_DIR, f"userdata/{user_id}")
    chat_state_file = os.path.join(user_data_path, f"{chat_id}.json")

    if os.path.exists(chat_state_file):
        with open(chat_state_file, 'r') as f:
            chat_data = json.load(f)
            messages = chat_data.get("messages", [])
            return JSONResponse(content={"messages": messages})

    return JSONResponse(content={"messages": []})


@chat_router.get('/chats', response_class=JSONResponse)
async def chats(request: Request, user_id: Optional[str] = Cookie(None)):
    user_data_path = os.path.join(CHAT_DIR, f"userdata/{user_id}")
    chat_sessions = []

    if user_id and os.path.exists(user_data_path):
        titles_cache_path = os.path.join(user_data_path, 'titles.cache')
        titles_cache = {}
        if os.path.exists(titles_cache_path):
            with open(titles_cache_path, 'r') as f:
                titles_cache = json.load(f)
        logging.debug(os.listdir(user_data_path))
        for filename in os.listdir(user_data_path):
            if filename == 'titles.cache':
                continue
            logging.debug(f"listdir {filename}")
            if len(filename) > 2:
                guid = filename.split('.')[0]
                if guid not in titles_cache:
                    try:
                        with open(os.path.join(user_data_path, filename), 'r') as f:
                            data = json.load(f)
                            title = data.get("title", "Title Not Available")
                    except Exception as e:
                        title = "Title Not Available"
                        logging.error(f"Exception occurred loading title: {e}")
                    titles_cache[guid] = title

                chat_sessions.append({"chatId": guid, "title": titles_cache[guid]})

        with open(titles_cache_path, 'w') as f:
            valid_cache = {k: v for k, v in titles_cache.items() if os.path.exists(os.path.join(user_data_path, f"{k}.json"))}
            json.dump(valid_cache, f)

    return JSONResponse(content=chat_sessions)


@chat_router.post('/chat/{chat_id}/title', response_class=JSONResponse)
async def update_chat_title(request: Request, chat_id: str, user_id: Optional[str] = Cookie(None)):
    """
    Updates the title of a chat session with the specified chat_id for the user.

    Args:
        request (Request): The request object.
        chat_id (str): The chat session ID to update the title for.
        user_id (Optional[str], optional): The user ID from cookies. Defaults to None.

    Returns:
        JSONResponse: A JSON response indicating success or failure of the title update.
    """
    try:
        data = await request.json()
        new_title = data.get('title')
    except Exception as e:
        logging.error(f"Error extracting title from request data: {e}")
        return JSONResponse(content={"success": False, "message": "Invalid request data format"})

    user_data_path = os.path.join(CHAT_DIR, f"userdata/{user_id}")
    titles_cache_path = os.path.join(user_data_path, 'titles.cache')
    titles_cache = {}

    if os.path.exists(titles_cache_path):
        with open(titles_cache_path, 'r') as f:
            titles_cache = json.load(f)

        chat_file_path = os.path.join(user_data_path, f"{chat_id}.json")
        if os.path.exists(chat_file_path):
            try:
                with open(chat_file_path, 'r') as chat_file:
                    chat_data = json.load(chat_file)
                    chat_data["title"] = new_title
                with open(chat_file_path, 'w') as chat_file:
                    json.dump(chat_data, chat_file)

                titles_cache[chat_id] = new_title

                with open(titles_cache_path, 'w') as f:
                    json.dump(titles_cache, f)

                return JSONResponse(content={"success": True})
            except Exception as e:
                logging.error(f"Error updating chat title: {e}")
                return JSONResponse(content={"success": False})
        else:
            return JSONResponse(content={"success": False, "message": "Chat session not found"})
    else:
        return JSONResponse(content={"success": False, "message": "Titles cache not found"})



